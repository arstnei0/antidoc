---
// Credit: Thanks for Astro Docs' team's hard work.
// Source: https://github.com/withastro/docs/blob/main/src/components/CodeSnippet/CodeSnippet.astro
// Some of the styles are fine-tuned.

import rangeParser from "parse-numeric-range"
import { ShikiBlock } from "./shiki-block"
import {
	InlineMarkingDefinition,
	LineMarkingDefinition,
	MarkerType,
	MarkerTypeOrder,
} from "./types"
import * as css from "./CodeSnippet.css"
import CopyCode from "./CopyCode"

export interface Props {
	lang?: string
	title?: string
	removedLineIndex?: string
	removedLineCount?: string
	lineMarkings?: string
	inlineMarkings?: string
	code: string
}

const {
	lang = "",
	removedLineIndex = "",
	removedLineCount = "",
	title = "",
	lineMarkings = "",
	inlineMarkings = "",
	code,
} = Astro.props as Props

const isTerminal = ["shellscript", "shell", "bash", "sh", "zsh"].includes(lang)
const intRemovedLineIndex = parseInt(removedLineIndex) || 0
const intRemovedLineCount = parseInt(removedLineCount) || 0

// Generate HTML code from the title (if any), improving the ability to wrap long file paths
// into multiple lines by inserting a line break opportunity after each slash
const titleHtml = decodeURIComponent(title).replace(/([\\/])/g, "$1<wbr/>")

// Render the default slot, which contains the syntax-highlighted code in HTML format
// as processed by Astro's Shiki integration
let codeSnippetHtml = await Astro.slots.render("default")

// Mark lines and expressions (if requested)
codeSnippetHtml = applyMarkings(codeSnippetHtml, lineMarkings, inlineMarkings)

function applyMarkings(
	highlightedCodeHtml: string,
	strLineMarkings: string,
	strInlineMarkings: string,
) {
	const lineMarkings: LineMarkingDefinition[] = parseMarkingDefinition(
		strLineMarkings,
		// Syntax: [mark=|del=|ins=]{2-5,7}
		/^(?:(.*)=){(.+)}$/,
		`Invalid code snippet line marking: Expected a range like "{2-5,7}",
		optionally with one of the prefixes "mark=", "del=" or "ins=", but got "$entry"`,
	).map(({ markerType, groupValues: [content] }) => {
		const lines = rangeParser(content)

		// If any lines were removed during preprocessing,
		// automatically shift marked line numbers accordingly
		const shiftedLines = lines.map(lineNum => {
			if (lineNum <= intRemovedLineIndex) return lineNum
			if (lineNum > intRemovedLineIndex + intRemovedLineCount)
				return lineNum - intRemovedLineCount
			return -1
		})

		return {
			markerType,
			lines: shiftedLines,
		}
	})

	const inlineMarkings: InlineMarkingDefinition[] = parseMarkingDefinition(
		strInlineMarkings,
		// Syntax for plaintext strings:
		// - Double quotes:   [mark=|del=|ins=]"<Button />"
		// - Single quotes:   [mark=|del=|ins=]'<p class="hi">'
		//
		// Syntax for regular expressions:
		// - Forward slashes: [mark=|del=|ins=]/hi [a-z]+/
		/^(?:(.*)=)([/"'])(.+)\2$/,
		`Invalid code snippet inline marking: Expected either a string in single or double quotes,
		or a RegExp in forward slashes like "/hi [a-z]+/", optionally with one of the prefixes
		"mark=", "del=" or "ins=", but got "$entry"`,
	).map(({ markerType, groupValues: [delimiter, content] }) => {
		let text: string | undefined
		let regExp: RegExp | undefined

		if (delimiter === "/") {
			try {
				// Try to use regular expressions with capture group indices
				regExp = new RegExp(content, "gd")
			} catch (error) {
				// Use fallback if unsupported
				regExp = new RegExp(content, "g")
			}
		} else {
			text = content
		}

		return {
			markerType,
			text,
			regExp,
		}
	})

	const shikiBlock = new ShikiBlock(highlightedCodeHtml)
	shikiBlock.applyMarkings(lineMarkings, inlineMarkings)
	return shikiBlock.renderToHtml()
}

function parseMarkingDefinition(serializedArr: string, parts: RegExp, parseErrorMsg: string) {
	return serializedArr
		.split(",")
		.map(entry => decodeURIComponent(entry))
		.map(entry => {
			const matches = entry.match(parts)
			let rawMarkerType = matches?.[1]
			// Fix common marker type mistakes
			if (rawMarkerType === "add") rawMarkerType = "ins"
			if (rawMarkerType === "rem") rawMarkerType = "del"
			const markerType = (rawMarkerType as MarkerType) || "mark"
			const isValid = matches && MarkerTypeOrder.includes(markerType)
			if (entry && !isValid) {
				const formattedParseErrorMsg = parseErrorMsg
					.replace("$entry", entry)
					.replace(/\r?\n\s+/g, " ")
				console.error(`*** ${formattedParseErrorMsg}\n`)
			}
			return {
				entry,
				markerType: markerType,
				groupValues: isValid ? matches.slice(2) : [],
			}
		})
		.filter(entry => entry.groupValues.length)
}
---

<figure
	class:list={[
		css.codeSnippet,
		isTerminal && "is-terminal",
		titleHtml && "has-title",
		`lang-${lang}`,
	]}
>
	<figcaption class={css.header}>
		{
			titleHtml ? (
				<span class={css.headerTitle} set:html={titleHtml} />
			) : (
				isTerminal && <span class="sr-only">Terminal</span>
			)
		}
	</figcaption>
	<Fragment set:html={codeSnippetHtml} />
	<CopyCode code={code} client:idle />
</figure>
